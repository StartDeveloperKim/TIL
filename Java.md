# Java
## 개요
- [Java의 특징, JDK와 JRE]()
- [JVM]()
- [==와 equals()의 차이]()
- [final과 불변의 중요성]()
  
## Java의 특징, JDK와 JRE
### 객체지향언어이다

- 다형성, 추상화, 캡슐화, 상속 등의 객체지향의 특성을 살려 프로그래밍할 수 있는 언어이다.
- 코드를 클래스와 객체의 형태로 구성하여 모듈화하고 재사용성을 높일 수 있다.

### JVM위에서 동작하여 OS에 독립적인 언어이다

- 이는 Java가 바이트 코드로 컴파일되어 JVM 위에서 동작하므로 운영체제에 독립적이다.
- 다만, JVM위에서 동작하므로 다른 컴파일언어에 비해 느리다.

### 동적로딩을 지원한다.

- 동적로딩을 지원한다.
- 애플리케이션이 실행될 때 모든 객체가 생성되지 않고, 각 객체가 필요한 시점에 클래스를 동적 로딩해서 생성된다.

### 자동 메모리 관리

- Java는 가비지 컬렉션 기능을 통해 메모리 관리를 자동화하며, 개발자가 명시적으로 메모리를 해제하지 않아도 된다.

---

### “JDK와 JRE의 차이점은?”

#### JDK(Java Development Kit)
- JDK는 Java 프로그램을 개발하고 컴파일하는 데 필요한 도구와 라이브러리를 포함한다.
- Java 애플리케이션을 작성하고 실행할 때 필요한 도구를 제공한다.

#### JRE(Java Runtime Environment)
- JRE는 Java 애플리케이션을 실행하기 위한 실행 환경이다.
- JVM과 필요한 라이브러리 및 실행에 필요한 모든 구성 요소를 포함한다.
- 사용자가 Java 프로그램을 실행하려면 시스템에 JRE가 설치되어 있어야한다.

> 즉 , JDK는 JRE를 포함한다고 할 수 있다.

------------

## JVM(Java Virtual Machine)
 - JVM은 Java 애플리케이션을 실행하는 가상 컴퓨터이다.
 - 컴퓨터 하드웨어와 운영 체제에 의존하지 않고 Java 바이트 코드를 실행할 수 있게 해준다.
 - JVM은 자바 코드를 컴파일해서 생성된 바이트 코드를 실행하고, 메모리 관리와 가비지 컬렉션 등의 작업
을 처리한다.

### JVM의 역할
-  **플랫폼 독립성:** JVM은 "Write Once, Run Anywhere" 원칙을 실현하여, 한 번 작성한 자바 코드를 다양한 플랫폼에서 실행할 수 있도록 해줍니다. 
-  **바이트 코드 실행:** 자바 컴파일러에 의해 생성된 바이트 코드를 읽고 실행 가능한 기계 코드로 변환하여 프로그램을 실행합니다.
-  **메모리 관리:** 객체의 생성과 해제, 가비지 컬렉션 등 메모리 관리 작업을 처리하여 개발자가 메모리를 직접 관리할 필요가 없도록 합니다. 
- **다중 스레드 관리:** 다중 스레드 프로그래밍을 지원하여 여러 작업을 동시에 실행하고 관리합니다.

 ### JVM의 메모리 공간
 JVM은 프로그램 실행 중에 필요한 메모리를 관리하는데, 이 메모리는 여러 영역으로 분리되어 있다.
 #### Method
 - Method 영역은 클래스 정보와 정적 변수들이 저장되는 공간이다.
 - 이 영역은 모든 스레드가 공유하며, 클래스 로더에 의해 로딩된 클래스의 메타데이터, 상수 풀, 메서드와 필드의 정보 등이 저장된다.
 #### Heap
 - Heap은 객체들의 인스턴스와 배열을 저장하는 공간이다.
 - 동적으로 생성된 객체들이 할당되는 영역이고, 해당 영역은 Garbage Collection 작업으로 메모리를 관리하여 더 이상 사용되지 않는 객체들을 정리한다.
 #### Stack
 -  Stack은 각 스레드마다 별도로 할당되는 메모리 영역으로, 메서드 호출과 관련된 정보를 저장한다.
 - 메서드가 호출될 때마다 호출된 메서드의 정보와 지역 변수, 매게변수 등이 스택에 추가되며, 메서드가 반환되면 해당 정보가 제거된다.
 
#### PC 레지스터
- PC레지스터는 현재 실행 중인 명령어의 주소를 저장하는 공간이다.
- 스레드마다 별도로 유지되며, 명령어 실행 위치를 추적하고 다음에 실행할 명령어를 지정하는 역할을 한다.
#### Native Method Stack
- 자바 코드가 아닌 다른 언어로 작성된 네이티브 메서드를 위한 공간이다.
- 네이티브 메서드는 자바 코드에서 네이티브 라이브러리를 호출할 때 사용된다.
#### Direct Memory
- 네이티브 코드에서 직접적으로 메모리를 할당하고 관리하는 영역이다.
- 이는 Java Heap 외부에서 관리되는 메모리로, 네이티브 라이브러리를 통해 사용된다.
### JVM의 동작 원리
1. **컴파일**
> **개발자가 작성한 자바 소스 코드는 '.java' 파일로 저장된다. 이 소스 코드는 자바 컴파일러에 의해 바이트 코드로 변환한다.** 
2. **클래스 로딩**
> **변환된 바이트 코드는 JVM의 메모리 중 메서드 영역에 로딩된다. 이 때, 클래스 로더는 필요한 클래스를 찾아 로딩하고 초기화한다.**
3. **바이트 코드 해석 및 실행**
> **JVM은 바이트 코드를 인터프리터 또는 JIT 컴파일러를 통해 실행 가능한 기계 코드로 변환하여 실행한다.**
4. **메모리 관리 및 가비지 컬렉션**
> **JVM은 힙 영역에 생성된 객체들을 관리하고, 더 이상 사용되지 않는 객체들을 가비지 컬렉션을 통해 정리한다.**

------

## ==와 equals()의 차이
`==` 연산자와 `equals()` 메서드는 두 객체가 같은 객체인지 확인하는데 사용되는 연산자 및 메서드이다. 그러나 두 개념 간에는 동일성과 동등성이라는 개념적 차이가 있다.

**동일성 (Identity):** 
동일성은 두 객체가 메모리 상에서 정확히 같은 위치에 위치하는지를 판단한다. 다시 말해, 두 객체가 물리적으로 동일한 인스턴스인지를 검사한다.

**동등성 (Equality):** 
동등성은 두 객체가 논리적으로 같은 값을 가지는지를 판단한다. 예를 들어, 특정 필드의 값이 동일한 경우 두 객체를 논리적으로 같다고 판단한다.

`==` 연산자는 동일성을 판단하는 데 사용된다. 즉, 비교하는 두 객체가 메모리 상에서 동일한 위치에 있는지를 확인한다.

반면에 `equals()` 메서드는 동등성을 판단하는 데 사용된다. 하지만 기본적으로 Java의 모든 클래스는 `equals()`를 Object 클래스에서 상속받는다. 이 상태에서는 `equals()`가 내부적으로 `==` 연산자를 사용하여 동일성 비교를 수행한다. 따라서 개발자가 동등성을 비교하고자 한다면 해당 클래스에서 `equals()` 메서드를 오버라이딩하여 논리적인 비교를 의도에 맞게 구현해야 한다.


![image](https://github.com/StartDeveloperKim/TIL/assets/97887047/54f251fb-e3e3-4f2e-8864-0383fb6ef5e9)

-----------

## final과 불변의 중요성
**'final' 키워드는 자바에서 클래스, 필드, 메서드의 파라미터 등을 불변으로 설정할 때 사용되는 키워드이다.** 

그럼 불변으로 설정해야하는 이유는 뭘까?

### 1. 변경 가능성을 줄여줌
'final'을 붙인 클래스의 필드는 해당 클래스의 객체가 생성될 때 초기화가 이뤄진다. 이 때 초기화를 하지 않으면 컴파일 에러가 발생하며, 중간에 값을 변경하려는 시도도 컴파일 에러로 표시된다. 즉, 변경되면 안 되는 데이터에 'final'을 사용함으로써 의도치 않은 데이터 변경을 방지할 수 있다.

이로 인해 코드의 코드의 변경 가능성을 줄여주는 효과가 있습니다. 여러 사람들이 협업하거나 여러 시스템이 연동되는 환경에서 이러한 실수를 방지할 수 있다.

#### 메서드 오버라이딩
- 'final'로 선언된 메서드는 하위 클래스에서 오버라이딩할 수 없다. 
- 이는 상위 클래스에서의 메서드 동작을 변경하지 못하게 하여 클래스 계층 구조의 안정성을 유지할 수 잇다.
#### 상속과 'final' 클래스
- 클래스를 'final'로 선언하면 해당 클래스를 상속할 수 없다.
- 이로써 클래스의 의도된 동작을 변경하지 못하게 하여 안정성을 유지하거나 외부에서 오용을 방지할 수 있다.

### 2. 멀티스레드 환경에서의 안정성
'final'로 선언된 데이터는 한 번 초기화되면 변경할 수 없다. 이러한 특성으로 인해 멀티스레드 환경에서 안정성을 확보할 수 있다. 

멀티스레드 환경에서 여러 스레드가 동시에 접근하여 데이터를 변경하려는 시도가 발생할 수 있다. 이런 경우 변경 불가능한 데이터는 스레드 간의 동기화 없이도 안전하게 공유될 수 있다. 즉, 'final'로 불변성을 확보하면 스레드 간의 Race Condition과 같은 문제를 예방할 수 있다.


